{"meta":{"title":"DragonDreamYF","subtitle":null,"description":null,"author":"DragonDreamYF","url":"https://dragondreamyf.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-16","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-16","excerpt":""}],"posts":[{"title":"普通平衡树之 Splay ","text":"颓了一个暑假来更新一下blog的蒟蒻我是在夏令营接触的平衡树 Splay， 在当时并不是很理解， 所以查阅了很多资料， 但并不是很满意， 于是我打算自己写一个Splay入门， 顺便当作一种温习。 前言：毕竟是入门，并且博主也只会入门，所以如有错误，再三见谅，请加QQ提出。SplayP3369 【模板】普通平衡树 首先贴个例题，毕竟看着题才容易加深理解。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std ;struct node &#123; int fa ; int cnt ; int son ; int ch[2] ; int val ;&#125;t[500100] ;int root = 0 ;int n ;int tot ;void push_up (int x) &#123; t[x] . son = t[t[x] . ch[1]] . son + t[t[x] . ch[0]] . son + t[x] . cnt ;&#125;void rotate (int x) &#123; int y = t[x] . fa ; int z = t[y] . fa ; int k = t[y] . ch[1] == x ; t[z] . ch[t[z] . ch[1] == y] = x ; t[x] . fa = z ; t[y] . ch[k] = t[x] . ch[k ^ 1] ; t[t[x] . ch[k ^ 1]] . fa = y ; t[x] . ch[k ^ 1] = y ; t[y] . fa = x ; push_up (y) ; push_up (x) ;&#125;void Splay (int x, int goal) &#123; while (t[x] . fa != goal) &#123; int y = t[x] . fa ; int z = t[y] . fa ; if (z != goal) (t[z] . ch[0] == y) ^ (t[y] . ch[0] == x) ? rotate (x) : rotate (y) ; rotate (x) ; &#125; if (goal == 0) root = x ;&#125;void insert (int x) &#123; int u = root ; int fa = 0 ; while (u &amp;&amp; t[u] . val != x) &#123; fa = u ; u = t[u] . ch[x &gt; t[u] . val] ; &#125; if (u) t[u] . cnt ++ ; else &#123; u = ++ tot ; if (fa) t[fa] . ch[x &gt; t[fa] . val] = u ; t[u] . fa = fa ; t[u] . val = x ; t[u] . ch[0] = 0 ; t[u] . ch[1] = 0 ; t[u] . son = 1 ; t[u] . cnt = 1 ; &#125; Splay (u, 0) ;&#125;void find (int x) &#123; int u = root ; if (!u) return ; while (t[u] . ch[x &gt; t[u] . val] &amp;&amp; t[u] . val != x) u = t[u] . ch[x &gt; t[u] . val] ; Splay (u, 0) ;&#125;int Next (int x, int f) &#123; find (x) ; int u = root ; if ((t[u] . val &gt; x &amp;&amp; f) || (t[u] . val &lt; x &amp;&amp; !f)) return u ; u = t[u] . ch[f] ; while (t[u] . ch[f ^ 1]) u = t[u] . ch[f ^ 1] ; return u ;&#125;void Delete (int x) &#123; int last = Next (x, 0) ; int next = Next (x, 1) ; Splay (last, 0) ; Splay (next, last) ; int del = t[next] . ch[0] ; if (t[del] . cnt &gt; 1) &#123; t[del] . cnt -- ; Splay (del, 0) ; &#125; else t[next] . ch[0] = 0 ;&#125;int rnk (int x) &#123; int u = root ; if (t[u] . son &lt; x) return false ; while (1) &#123; int y = t[u] . ch[0] ; if (x &gt; t[y] . son + t[u] . cnt) &#123; x -= t[y] . son + t[u] . cnt ; u = t[u] . ch[1] ; &#125; else if (t[y] . son &gt;= x) u = y ; else return t[u] . val ; &#125;&#125;int main() &#123; insert (2147483647) ; insert (-2147483647) ; cin &gt;&gt; n ; for (int i = 1; i &lt;= n; i++) &#123; int flag, x ; cin &gt;&gt; flag ; cin &gt;&gt; x ; if (flag == 1) &#123; insert (x) ; &#125; if (flag == 2) &#123; Delete (x) ; &#125; if (flag == 3) &#123; find (x) ; cout &lt;&lt; t[t[root] . ch[0]] . son &lt;&lt; endl ; &#125; if (flag == 4) &#123; cout &lt;&lt; rnk (x + 1) &lt;&lt; endl ; &#125; if (flag == 5) &#123; cout &lt;&lt; t[Next (x, 0)] . val &lt;&lt; endl ; &#125; if (flag == 6) &#123; cout &lt;&lt; t[Next (x, 1)] . val &lt;&lt; endl ; &#125; &#125; return 0 ;&#125; 嘛，板子贴出来了，想复制就复制吧，我不拦着。 呐，对了，本题我是靠着yyb大佬的题解撑过来的，如有雷同，那很正常。 读题可知，要解决本题，需要六个操作，然而5，6可以合并，所以是5个主操作，我将逐个为你讲解。 首先，关于结构体的定义。 1234567struct node &#123; int fa ;// fa 代表的是他的父亲 int cnt ;// cnt 代表的是他的个数，也就是说有几个和他相同的数 int son ;// son 代表的是他儿子的个数 int ch[2] ;// 代表的是他的左右子节点，即两个儿子，ch[0] 指的是小于他的儿子，ch[1] 代表的是大于他的儿子 int val ;// val 代表的是当前这个位置的值&#125;t[500100] ;","path":"2019/08/01/普通平衡树之-Splay/","date":"08-01","excerpt":"","tags":[{"name":"Splay","slug":"Splay","permalink":"https://dragondreamyf.github.io/tags/Splay/"}]},{"title":"树状数组的学习","text":"树状数组的学习当然作为蒟蒻的我也仅仅是才开始学习QAQ 咳咳，下面进入正文qwq： 当然，在进行树状数组的运用之前，要先了解一下何为树状数组。 树状数组是什么？数组如其名，它就是一个树状的数组（类似于二叉树好吧就是） 对于 a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]. 我们定义 c[1] = a[1] c[2] = a[1] + a[2] c[3] = a[3] c[4] = a[1] + a[2] + a[3] + a[4] c[5] = a[5] c[6] = a[5] + a[6] c[7] = a[7] c[8] = a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8]此处不贴图我感觉反而方便理解 于是，我们大胆地将其转换成二进制ヾ(≧▽≦)o c[1] = c[0001] = a[1] c[2] = c[0010] = a[1] + a[2] c[3] = c[0011] = a[3] c[4] = c[0100] = a[1] + a[2] + a[3] + a[4] c[5] = c[0101] = a[5] c[6] = c[0110] = a[5] + a[6] c[7] = c[0111] = a[7] c[8] = c[1000] = a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] c[i] = a[i - 2 ^ k + 1] + a[i - 2 ^ k + 2] + …… +a[i]k 为 i 的二进制中从最低位到第一个高位 “1” 的连续零的长度 i = 8 (1000) 时 k = 3 我们知道,对于一个数的负数就等于对这个数取反+1 以二进制数11010为例:11010的补码为00101,加1后为00110,两者相与便是最低位的1 其实很好理解,补码和原码必然相反,所以原码有0的部位补码全是1,补码再+1之后由于进位那么最末尾的1和原码 最右边的1一定是同一个位置(当遇到第一个1的时候补码此位为0,由于前面会进一位,所以此位会变为1) 所以我们只需要进行a&amp;(-a)就可以取出最低位的1了 于是 1lowbit (int x) &#123; return x &amp; (-x) ; &#125; 单点修改 因为这是一个树状的数组，所以在对 a[i] 进行更新时，必定会同步更新 c 数组 1(001) c[1] += a[1] lowbit (1)= 001 = 1 + lowbit(1) = 2(010) c[2] += a[1] lowbit (2)= 010 = 2 + lowbit(2) = 4(100) c[4] += a[1] lowbit (4)= 100 = 4 + lowbit(4) = 8(1000) c[8] += a[1] 12345void update (int x, int y) &#123; for (int i = x; i &lt;= n; i += lowbit (i)) &#123; c[i] += y ; &#125;&#125; 区间查询 emmmm…… 对于区间查询，呃，我实在是没有觉得有什么好说的 自己手推一下就出来了（然而花了我十多分钟QAQ） 说白了，区间查询就是单点修改的逆操作 因为是树状数组，所以每一个 c[] 对应着一段 a[] 或 一个 a[] 的和 举例来说，当我想求2 ~ 5的区间和时，我需要先求1 ~ 2的区间和，再求1 ~ 5的区间和，然后作差 即 1cout&lt;&lt;getsum(5) - getsum(2)&lt;&lt;endl ; 123456int getsum (int x) &#123; int ans = 0 ; for (int i = x; i; i -= lowbit (i)) ans += c[i] ; return ans ;&#125; 既然都已经会了，那么开始做题吧qwq HDU1166 敌兵布阵 嘛，没做完不许看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std ;int c[50001] ;int n, t ;string s ;int lowbit (int i) &#123; return i &amp; (-i) ;&#125;void update (int x, int y, int n) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) c[i] += y ;&#125;int getsum (int x) &#123; int ans = 0 ; for (int i = x; i != 0; i -= lowbit(i)) &#123; ans += c[i] ; &#125; return ans ;&#125;int main() &#123; cin&gt;&gt;t ; for (int k = 1; k &lt;= t; ++k) &#123; cout&lt;&lt;&quot;Case &quot;&lt;&lt;k&lt;&lt;&quot;:&quot;&lt;&lt;endl ; cin&gt;&gt;n ; memset (c, 0, n + 1 &lt;&lt; 2) ; // 巨坑无比，我在这个点上卡了三次，全是超时 // 切记不要 memset (c, 0, sizeof (c)) ; // 否则你会死的很难看QAQ for (int i = 1; i &lt;= n; i++) &#123; int z ; cin&gt;&gt;z ; update (i, z, n) ; &#125; while (1) &#123; cin&gt;&gt;s ; int x, y ; if (s[0] == &apos;E&apos;) &#123; break ; &#125; if (s[0] == &apos;A&apos;) &#123; cin&gt;&gt;x&gt;&gt;y ; update (x, y, n) ; continue ; // 这是习惯，可加可不加 &#125; if (s[0] == &apos;S&apos;) &#123; cin&gt;&gt;x&gt;&gt;y ; update (x, -y, n) ; continue ; &#125; if (s[0] == &apos;Q&apos;) &#123; cin&gt;&gt;x&gt;&gt;y ; cout&lt;&lt;getsum (y) - getsum (x - 1)&lt;&lt;endl ; continue ; &#125; &#125; &#125; return 0 ;&#125; 代码巨丑，请见谅（反正我也没有评论功能，有本事来打我呀） 进阶篇——-关于差分与树状数组本博主其实也不大会啦qwq(￣▽￣)”，所以对于听懂不要抱太大希望 对于本部分可以去看一下Dy大佬的blog RisingSunLight 差分","path":"2019/07/17/树状数组的学习/","date":"07-17","excerpt":"","tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://dragondreamyf.github.io/tags/树状数组/"}]}]}